<!-- TOC -->
* [GC](#gc)
  * [三色标记法](#三色标记法)
    * [三色标记法核心过程](#三色标记法核心过程)
    * [没有STW的三色标记法](#没有stw的三色标记法)
  * [屏障技术](#屏障技术)
    * [强三色不变性和弱三色不变性](#强三色不变性和弱三色不变性)
    * [屏障技术](#屏障技术-1)
      * [插入写屏障](#插入写屏障)
      * [删除写屏障](#删除写屏障)
      * [混合写屏障](#混合写屏障)
  * [小结](#小结)
<!-- TOC -->
# GC
1. 悬挂指针
答：指针指向的内存被回收，导致指向失效，即“悬空”。
2. 标记——清扫算法
- 将栈、数据段上的数据对象认为是root，基于root开始追踪，追踪到的数据进行标记。追踪不到的就是垃圾。
- 缺点：内存碎片化
  - 解决方案：BiBOP（Big Bag Of Pages）内存块划分为多种大小规格，相同规格内存统一管理，可以更快匹配到大小合适的空闲内存。
  - 标记整理算法，移动数据是内存使用紧凑化。
  - 复制式回收（堆内存分为from和to两个空间，from用于执行时分配，to用于将from中可追踪到的数据复制紧凑到to中，然后交换角色。
  - 分代回收：将数据分新生代（少数量GC就被回收）和老年代（经历了多次GC仍未被回收），可以降低老年代GC频率。可采用不同的回收策略。
3. 引用技术
- 一个数据对象被引用的次数

**2，3都是暂停用户程序，专注于垃圾回收前提下展开。STW（Stop the World）**
## 三色标记法
### 三色标记法核心过程
- 遍历灰色集合，将灰色对象标记为黑色，放到黑色集合中
- 将黑色对象引用的白色对象标记为灰色，放到灰色集合中
- 重复上面两个步骤，直到不存在灰色对象，并清除所有的白色对象

### 没有STW的三色标记法
不执行STW时，满足下面两个条件会破坏垃圾收集器的正确性：
- 条件1：某个黑色对象引用白色对象
- 条件2：从灰色对象出发，到达白色对象的，未经访问过的路径遭到破坏

## 屏障技术
### 强三色不变性和弱三色不变性
只要破坏“误杀”的两个必要条件，即可保证对象不丢失。
- 强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或黑色对象
- 弱三色不变性：黑色对象指向的白色对象，必须包含一条从灰色对象经由多个白色对象的可达路径

### 屏障技术
#### 插入写屏障
**在黑色对象引用一个白色对象时，将白色对象改为灰色**
在对象A引用对象B时，对象B被标记为灰色，满足强三色不变性。
（Go语言没有选择启用栈上的写屏障机制）
- 根集合：垃圾收集器在标记过程中最先检查的对象
  - 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量
  - 执行栈：每个Goroutine都包含自己的执行栈，执行栈上包含栈上变量及指向堆内存的指针
  - 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向堆内存

**为了避免性能开销，栈没有启用插入写屏障机制，此时可能存在白色对象被引用的情况，需要对栈重新扫描、考虑到重新扫描时，可能会一直产生新的白色对象被引用，所以启用STW直到栈空间的三色标记结束**

#### 删除写屏障
**在灰色对象引用白色对象时，用户将这个引用关系删除，触发写屏障仍然标记被删除的对象为灰色**
- 被删除的对象，如果自身为灰色或白色，那么被标记为灰色，满足弱三色不变性。
- 删除写屏障的优势在于标记阶段结束后能够准确回收不需要的内存，不需要重新扫描。但是它的回收精度低，一个对象的最后一个引用指针即使被删除了，该对象仍然能够在本轮垃圾回收存在，需要等到下一轮GC才能被清除

#### 混合写屏障
Go语言选择在标记阶段完成时暂停程序，将所有栈对象标记为白色，并重新扫描。

Go V1.8版本，结合部分插入写屏障和部分删除写屏障构成混合写屏障；
- 对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色。

## 小结
1. 插入写屏障

其实主要是针对插入新对象或者说是添加对象之间的引用关系，被插入的对象或者是被引用指向的对象标记为灰色，但是插入写屏障只能在堆上操作，这是因为Go在并发运行时，大部分的操作都发生在栈上，函数调用会非常频繁。数十万goroutine的栈都进行屏障保护会有严重的性能问题。

2. 删除写屏障

主要是断开引用关系，被断开连接的下一个对象直接标记为灰色，删除写屏障发生在堆上。

3. 混合写屏障

总体来说就是插入写屏障和删除写屏障的一个结合，因为插入写屏障不能在栈上执行，这就导致在一次正常的三色标记流程结束后，需要对栈上重新进行一次STW，
然后再rescan一次，增加了GC的性能损耗。所以混合写屏障对栈的操作是：在GC刚开始的时候，会将栈上的可达对象全部标记为黑色，gc过程中任何在栈上新创建的
对象，均为黑色。这样就可以保证三色标记流程结束后，不需要再对栈上重新进行一次rescan。在堆上的操作时：堆上被删除的对象标记为灰色，堆上新添加的
对象标记为灰色。