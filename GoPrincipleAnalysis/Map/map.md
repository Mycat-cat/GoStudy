# map
## Go语言中map的底层结构

1. 每个正常桶都有概率有一个溢出桶？
答：是的
2. tophash的作用是什么，为什么要选择用桶的键的哈希值的高8位做一个属性，怎么判定？
答：tophash的主要作用是快速确定一个键是否存在于某个桶中，以及它存储在桶中的哪个位置。
（1）快速比较：在查找键时，map会首先比较tophash数组中的值，而不是直接比较键的值。由于tophash数组较小且是直接访问的，可以大大加快查找速度。
（2）避免完整哈希计算：通过比较tophash，可以在不计算完整哈希值的情况下快速排除不匹配的键。
（3）指示空槽：tophash中的特殊值可以用来指示桶中的空槽，这样在插入时可以快速找到可用位置。
使用tophash的目的主要是为了提高map操作的效率，通过减少不必要的键比较和哈希计算，使得查找、插入和删除操作更快。
3. 为什么要先用tophash比而不用key直接比？
答：为了快速比对，hash前8位基本能确定两个key是否相同。（前8位相同key可同可不同，前8位不同key一定不同）

```go
type hmap struct {
	count      int              // map中元素个数，对应于len(map)的值
	flags      uint8            // 状态标志位，标记map的状态
	B          uint8            // 桶数以2为底的对数，如B = 3，那桶个数为2^3=8
	noverflow  uint16           // 溢出桶数量近似值
	hash0      uint32
	buckets    unsafe.Pointer
	oldbuckets unsafe.Pointer
	nevacuate  uintptr          // 扩容进度计数器
	extra      *mapextra  // 指向mapextra结构的指针，mapextra存储map中的溢出桶
}

type mapextra struct {
	overflow *[]*bmap       // 溢出桶链表地址
	oldoverflow *[]*bmap    // 老的溢出桶链表地址
	nextoverflow *bmap      // 下一个空闲溢出桶地址
}
```

### map的访问原理
```go
v     := map[key]
v, ok := map[key]
```
1. 判断map是否为空或者无数据，若为空或者无数据返回对应的空值。
2. map写检测，如果正处在写状态，表示此时不能进行操作。
3. 计算hash值和掩码。   掩码：掩码是一个位操作，通常用于哈希值的最后几位，以确定桶的位置。掩码的目的是将哈希值映射到一个较小的范围，通常是map桶的数量范围内。
```go
mask := uintptr(1)<<h.B - 1
bucketIndex := hashValue & mask
```
4. 判断当前map是否处于扩容状态，如果在扩容执行下面的步骤：
- 根据状态位（tophash[0]）判断当前桶是否发生迁移（通过将已经迁移的 bucket 的 tophash 设置为介于 emptyOne 和 minTopHash 之间的特殊值，Go 的 map 实现能够有效地区分已经迁移的 bucket 和正常的 bucket。evacuated 函数通过检查这个特殊的值范围来判断 bucket 是否已迁移。）
- 如果发生迁移，在新桶中查找
- 未被迁移，在旧桶中查找
- 根据掩码找到的位置
5. 依次遍历桶以及溢出桶来查找key
- 遍历桶内的8个槽位
- 比较该槽位的tophash和当前key的tophash是否相等
  - 相同，继续比较key是否相同，相同则直接返回对应value
  - 不相同，查看这个槽位的状态位是否为“后继空”状态
    - 是，key在以后的槽中也没有，这个key不存在，直接返回零值
    - 否，遍历下一个槽位
6. 当前桶没有找到，则遍历溢出桶，与上述方式一致

### map的赋值原理
```go
map[key] = value
```
1. map先初始化后赋值
2. map非线程安全，不支持并发读写操作

赋值大致流程：
1. map写检测，如果正处在写状态，表示此时不能进行读取，报fatal error
2. 计算hash值，将map置为写状态
3. 判断桶数组是否为空，若为空，初始化桶数组
4. 目标桶查找
- 根据hash值找到桶的位置
- 判断当前桶是否处于扩容：
  - 若正在扩容，迁移这个桶，并且还另外帮忙多迁移一个桶以及它的溢出桶
```go
为什么需要另外帮忙多迁移一个桶以及它的溢出桶？
（1）加速扩容过程：在扩容过程中，哈希表需要将旧桶中的元素迁移到新的桶中。这个过程需要时间，如果只在插入新元素时迁移当前桶，那么整个扩容过程可能会很慢，特别是在有大量插入操作的时候。通过额外迁移一个桶及其溢出桶，可以加快扩容过程，使哈希表更快地达到新的状态。
（2）减少并发冲突：在高并发环境中，如果多个 goroutine 同时进行插入操作，会导致频繁地触发扩容操作。如果每次插入只迁移当前桶，这会增加并发冲突的概率。通过额外迁移其他桶，可以减少这种冲突，因为每次插入操作都在尽量多地完成迁移工作，减小其他 goroutine 需要处理的工作量。
（3）避免长时间锁定：如果扩容过程中每次只迁移一个桶，可能会导致某些插入操作需要等待较长时间，因为每个插入操作都要等待之前的扩容完成。通过一次性多迁移一些桶，可以减少这种等待时间，提高整体的性能。
```
- 获取目标桶的指针，计算出tophash，开始后面的key查找过程
5. key查找
- 遍历桶和它的溢出桶的每个槽位，按下述方式寻找
- 判断槽位的tophash和目标tophash
  - 不相等
    - 槽位tophash为空，标记这个位置为候选位置（为什么不直接插入？因为后续未遍历到的位置可能已经存在这个key，如果这个key存在则会更新key对应的value，只有当这个key不存在才会插入）
    - 槽位tophash的标志位为“后继空状态”，说明这个key之前没有被插入过，插入key/value
    - tophash标志位不为空，说明存储着其他key，说明当前槽的tophash不符合，继续遍历下一个槽
  - 相等
    - 判断当前槽位的key与目标key是否相等
      - 不相等，继续遍历下一个槽位
      - 相等，找到了目标key的位置，原来已存在键值对，则修改key对应的value，然后执行收尾程序
6. key插入
- 若map中既没有找到key，且根据这个key找到的桶及其这个桶的溢出桶中没有空的槽位了，要申请一个新的溢出桶，在新申请的桶里插入
- 否则在找到的位置插入
7. 收尾程序
- 再次判断map的写状态
- 清除map的写状态

**需要注意：申请一个新的溢出桶的时候并不会直接创建一个，会优先使用map初始化时存储在extra \*mapextra字段中的溢出桶，只有这些预分配的溢出桶使用完了，才会新建**
